#spring.application.name=spring-boot-blog-app
#spring.datasource.url = jdbc:mysql://localhost:3306/ayushblog
#spring.datasource.username = root
#spring.datasource.password = Aryan@123
#
#spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQLDialect
#
## useful in dev mode: as it makes sure that if table is not present: please create that
#spring.jpa.hibernate.ddl-auto = update
#
## jwt properties:
#
#app.jwt-secret = java-is-everything
#app.jwt-expiration-milliseconds = 604800000
#
##spring security features
##spring.security.user.name = user
##spring.security.user.password = password
##spring.security.user.roles = ADMIN
#





spring.application.name=spring-boot-blog-app
spring.datasource.url=jdbc:mysql://localhost:3306/ayushblog
spring.datasource.username=root
spring.datasource.password=Aryan@123

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

spring.jpa.hibernate.ddl-auto=update

# JWT properties  : generate this using sha256 online encryption
app.jwt-secret=8bbf6ee1ddc68038be79e9cfdc8a7c35e0366873b470c5b36eeb006481218953
app.jwt-expiration-milliseconds=604800000
#logging.level.org.hibernate=DEBUG



# cloudinary image store credentials
cloudinary.cloud-name= dgz1lwjmk
cloudinary.api-key=162541985346481
cloudinary.api-secret=cB3WlCUqITTjnlGbMgfdkx5PshQ

# sending mail service for confirmation
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=ayusharyan1309@gmail.com
spring.mail.password=vldz hgsf kwia fgku
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# kafka services
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=my-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.enable-auto-commit=true
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer


spring.kafka.producer.properties.max.block.ms=5000
spring.kafka.consumer.properties.session.timeout.ms=10000

# Redis cloud setup
spring.redis.host=redis-17989.c264.ap-south-1-1.ec2.redns.redis-cloud.com
spring.redis.port=17989
spring.redis.username=default
spring.redis.password=VjDIjcte5WgqdTocFDJ5umZZprYjjClT
spring.redis.ssl=true


#logging.level.org.springframework=DEBUG






# Commented Spring Security user properties (assuming you're using custom JWT-based authentication)
#spring.security.user.name=user
#spring.security.user.password=password
#spring.security.user.roles=ADMIN




# application.properties
logging.level.com.blog=INFO
logging.file.name=app.log
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n